{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Haunschmied.Bastian/Documents/GitHub/Feuerwehr-Bezahlsystem/TestWebApp/Bezahlwebsite/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AuthenticationResultStatus } from '../authorize.service';\nimport { BehaviorSubject } from 'rxjs';\nimport { LoginActions, QueryParameterNames, ApplicationPaths, ReturnUrlType } from '../api-authorization.constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../authorize.service\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"@angular/common\"; // The main responsibility of this component is to handle the user's login process.\n// This is the starting point for the login process. Any component that needs to authenticate\n// a user can simply perform a redirect to this component with a returnUrl query parameter and\n// let the component perform the login and return back to the return url.\n\nexport let LoginComponent = /*#__PURE__*/(() => {\n  class LoginComponent {\n    constructor(authorizeService, activatedRoute, router) {\n      this.authorizeService = authorizeService;\n      this.activatedRoute = activatedRoute;\n      this.router = router;\n      this.message = new BehaviorSubject(null);\n    }\n\n    ngOnInit() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const action = _this.activatedRoute.snapshot.url[1];\n\n        switch (action.path) {\n          case LoginActions.Login:\n            yield _this.login(_this.getReturnUrl());\n            break;\n\n          case LoginActions.LoginCallback:\n            yield _this.processLoginCallback();\n            break;\n\n          case LoginActions.LoginFailed:\n            const message = _this.activatedRoute.snapshot.queryParamMap.get(QueryParameterNames.Message);\n\n            _this.message.next(message);\n\n            break;\n\n          case LoginActions.Profile:\n            _this.redirectToProfile();\n\n            break;\n\n          case LoginActions.Register:\n            _this.redirectToRegister();\n\n            break;\n\n          default:\n            throw new Error(`Invalid action '${action}'`);\n        }\n      })();\n    }\n\n    login(returnUrl) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const state = {\n          returnUrl\n        };\n        const result = yield _this2.authorizeService.signIn(state);\n\n        _this2.message.next(undefined);\n\n        switch (result.status) {\n          case AuthenticationResultStatus.Redirect:\n            break;\n\n          case AuthenticationResultStatus.Success:\n            yield _this2.navigateToReturnUrl(returnUrl);\n            break;\n\n          case AuthenticationResultStatus.Fail:\n            yield _this2.router.navigate(ApplicationPaths.LoginFailedPathComponents, {\n              queryParams: {\n                [QueryParameterNames.Message]: result.message\n              }\n            });\n            break;\n\n          default:\n            throw new Error(`Invalid status result ${result.status}.`);\n        }\n      })();\n    }\n\n    processLoginCallback() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const url = window.location.href;\n        const result = yield _this3.authorizeService.completeSignIn(url);\n\n        switch (result.status) {\n          case AuthenticationResultStatus.Redirect:\n            // There should not be any redirects as completeSignIn never redirects.\n            throw new Error('Should not redirect.');\n\n          case AuthenticationResultStatus.Success:\n            yield _this3.navigateToReturnUrl(_this3.getReturnUrl(result.state));\n            break;\n\n          case AuthenticationResultStatus.Fail:\n            _this3.message.next(result.message);\n\n            break;\n        }\n      })();\n    }\n\n    redirectToRegister() {\n      this.redirectToApiAuthorizationPath(`${ApplicationPaths.IdentityRegisterPath}?returnUrl=${encodeURI('/' + ApplicationPaths.Login)}`);\n    }\n\n    redirectToProfile() {\n      this.redirectToApiAuthorizationPath(ApplicationPaths.IdentityManagePath);\n    }\n\n    navigateToReturnUrl(returnUrl) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        // It's important that we do a replace here so that we remove the callback uri with the\n        // fragment containing the tokens from the browser history.\n        yield _this4.router.navigateByUrl(returnUrl, {\n          replaceUrl: true\n        });\n      })();\n    }\n\n    getReturnUrl(state) {\n      const fromQuery = this.activatedRoute.snapshot.queryParams.returnUrl; // If the url is coming from the query string, check that is either\n      // a relative url or an absolute url\n\n      if (fromQuery && !(fromQuery.startsWith(`${window.location.origin}/`) || /\\/[^\\/].*/.test(fromQuery))) {\n        // This is an extra check to prevent open redirects.\n        throw new Error('Invalid return url. The return url needs to have the same origin as the current page.');\n      }\n\n      return state && state.returnUrl || fromQuery || ApplicationPaths.DefaultLoginRedirectPath;\n    }\n\n    redirectToApiAuthorizationPath(apiAuthorizationPath) {\n      // It's important that we do a replace here so that when the user hits the back arrow on the\n      // browser they get sent back to where it was on the app instead of to an endpoint on this\n      // component.\n      const redirectUrl = `${window.location.origin}/${apiAuthorizationPath}`;\n      window.location.replace(redirectUrl);\n    }\n\n  }\n\n  LoginComponent.ɵfac = function LoginComponent_Factory(t) {\n    return new (t || LoginComponent)(i0.ɵɵdirectiveInject(i1.AuthorizeService), i0.ɵɵdirectiveInject(i2.ActivatedRoute), i0.ɵɵdirectiveInject(i2.Router));\n  };\n\n  LoginComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: LoginComponent,\n    selectors: [[\"app-login\"]],\n    decls: 3,\n    vars: 3,\n    template: function LoginComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"p\");\n        i0.ɵɵtext(1);\n        i0.ɵɵpipe(2, \"async\");\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, ctx.message));\n      }\n    },\n    dependencies: [i3.AsyncPipe]\n  });\n  return LoginComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}