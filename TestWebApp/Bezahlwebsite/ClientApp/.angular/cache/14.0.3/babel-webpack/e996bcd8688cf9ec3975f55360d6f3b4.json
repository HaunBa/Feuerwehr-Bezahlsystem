{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Haunschmied.Bastian/Documents/GitHub/Feuerwehr-Bezahlsystem/TestWebApp/Bezahlwebsite/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { UserManager } from 'oidc-client';\nimport { BehaviorSubject, concat, from } from 'rxjs';\nimport { filter, map, mergeMap, take, tap } from 'rxjs/operators';\nimport { ApplicationPaths, ApplicationName } from './api-authorization.constants';\nimport * as i0 from \"@angular/core\";\nexport var AuthenticationResultStatus = /*#__PURE__*/(() => {\n  (function (AuthenticationResultStatus) {\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Success\"] = 0] = \"Success\";\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Redirect\"] = 1] = \"Redirect\";\n    AuthenticationResultStatus[AuthenticationResultStatus[\"Fail\"] = 2] = \"Fail\";\n  })(AuthenticationResultStatus || (AuthenticationResultStatus = {}));\n\n  return AuthenticationResultStatus;\n})();\nexport let AuthorizeService = /*#__PURE__*/(() => {\n  class AuthorizeService {\n    constructor() {\n      // By default pop ups are disabled because they don't work properly on Edge.\n      // If you want to enable pop up authentication simply set this flag to false.\n      this.popUpDisabled = true;\n      this.userSubject = new BehaviorSubject(null);\n    }\n\n    isAuthenticated() {\n      return this.getUser().pipe(map(u => !!u));\n    }\n\n    getUser() {\n      return concat(this.userSubject.pipe(take(1), filter(u => !!u)), this.getUserFromStorage().pipe(filter(u => !!u), tap(u => this.userSubject.next(u))), this.userSubject.asObservable());\n    }\n\n    getAccessToken() {\n      return from(this.ensureUserManagerInitialized()).pipe(mergeMap(() => from(this.userManager.getUser())), map(user => user && user.access_token));\n    } // We try to authenticate the user in three different ways:\n    // 1) We try to see if we can authenticate the user silently. This happens\n    //    when the user is already logged in on the IdP and is done using a hidden iframe\n    //    on the client.\n    // 2) We try to authenticate the user using a PopUp Window. This might fail if there is a\n    //    Pop-Up blocker or the user has disabled PopUps.\n    // 3) If the two methods above fail, we redirect the browser to the IdP to perform a traditional\n    //    redirect flow.\n\n\n    signIn(state) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this.ensureUserManagerInitialized();\n        let user = null;\n\n        try {\n          user = yield _this.userManager.signinSilent(_this.createArguments());\n\n          _this.userSubject.next(user.profile);\n\n          return _this.success(state);\n        } catch (silentError) {\n          // User might not be authenticated, fallback to popup authentication\n          console.log('Silent authentication error: ', silentError);\n\n          try {\n            if (_this.popUpDisabled) {\n              throw new Error('Popup disabled. Change \\'authorize.service.ts:AuthorizeService.popupDisabled\\' to false to enable it.');\n            }\n\n            user = yield _this.userManager.signinPopup(_this.createArguments());\n\n            _this.userSubject.next(user.profile);\n\n            return _this.success(state);\n          } catch (popupError) {\n            if (popupError.message === 'Popup window closed') {\n              // The user explicitly cancelled the login action by closing an opened popup.\n              return _this.error('The user closed the window.');\n            } else if (!_this.popUpDisabled) {\n              console.log('Popup authentication error: ', popupError);\n            } // PopUps might be blocked by the user, fallback to redirect\n\n\n            try {\n              yield _this.userManager.signinRedirect(_this.createArguments(state));\n              return _this.redirect();\n            } catch (redirectError) {\n              console.log('Redirect authentication error: ', redirectError);\n              return _this.error(redirectError);\n            }\n          }\n        }\n      })();\n    }\n\n    completeSignIn(url) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          yield _this2.ensureUserManagerInitialized();\n          const user = yield _this2.userManager.signinCallback(url);\n\n          _this2.userSubject.next(user && user.profile);\n\n          return _this2.success(user && user.state);\n        } catch (error) {\n          console.log('There was an error signing in: ', error);\n          return _this2.error('There was an error signing in.');\n        }\n      })();\n    }\n\n    signOut(state) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          if (_this3.popUpDisabled) {\n            throw new Error('Popup disabled. Change \\'authorize.service.ts:AuthorizeService.popupDisabled\\' to false to enable it.');\n          }\n\n          yield _this3.ensureUserManagerInitialized();\n          yield _this3.userManager.signoutPopup(_this3.createArguments());\n\n          _this3.userSubject.next(null);\n\n          return _this3.success(state);\n        } catch (popupSignOutError) {\n          console.log('Popup signout error: ', popupSignOutError);\n\n          try {\n            yield _this3.userManager.signoutRedirect(_this3.createArguments(state));\n            return _this3.redirect();\n          } catch (redirectSignOutError) {\n            console.log('Redirect signout error: ', redirectSignOutError);\n            return _this3.error(redirectSignOutError);\n          }\n        }\n      })();\n    }\n\n    completeSignOut(url) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this4.ensureUserManagerInitialized();\n\n        try {\n          const response = yield _this4.userManager.signoutCallback(url);\n\n          _this4.userSubject.next(null);\n\n          return _this4.success(response && response.state);\n        } catch (error) {\n          console.log(`There was an error trying to log out '${error}'.`);\n          return _this4.error(error);\n        }\n      })();\n    }\n\n    createArguments(state) {\n      return {\n        useReplaceToNavigate: true,\n        data: state\n      };\n    }\n\n    error(message) {\n      return {\n        status: AuthenticationResultStatus.Fail,\n        message\n      };\n    }\n\n    success(state) {\n      return {\n        status: AuthenticationResultStatus.Success,\n        state\n      };\n    }\n\n    redirect() {\n      return {\n        status: AuthenticationResultStatus.Redirect\n      };\n    }\n\n    ensureUserManagerInitialized() {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this5.userManager !== undefined) {\n          return;\n        }\n\n        const response = yield fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);\n\n        if (!response.ok) {\n          throw new Error(`Could not load settings for '${ApplicationName}'`);\n        }\n\n        const settings = yield response.json();\n        settings.automaticSilentRenew = true;\n        settings.includeIdTokenInSilentRenew = true;\n        _this5.userManager = new UserManager(settings);\n\n        _this5.userManager.events.addUserSignedOut( /*#__PURE__*/_asyncToGenerator(function* () {\n          yield _this5.userManager.removeUser();\n\n          _this5.userSubject.next(null);\n        }));\n      })();\n    }\n\n    getUserFromStorage() {\n      return from(this.ensureUserManagerInitialized()).pipe(mergeMap(() => this.userManager.getUser()), map(u => u && u.profile));\n    }\n\n  }\n\n  AuthorizeService.ɵfac = function AuthorizeService_Factory(t) {\n    return new (t || AuthorizeService)();\n  };\n\n  AuthorizeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthorizeService,\n    factory: AuthorizeService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthorizeService;\n})();","map":null,"metadata":{},"sourceType":"module"}