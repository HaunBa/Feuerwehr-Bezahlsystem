{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Haunschmied.Bastian/Documents/GitHub/Feuerwehr-Bezahlsystem/TestWebApp/Bezahlwebsite/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AuthenticationResultStatus } from '../authorize.service';\nimport { BehaviorSubject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { LogoutActions, ApplicationPaths, ReturnUrlType } from '../api-authorization.constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../authorize.service\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"@angular/common\"; // The main responsibility of this component is to handle the user's logout process.\n// This is the starting point for the logout process, which is usually initiated when a\n// user clicks on the logout button on the LoginMenu component.\n\nexport let LogoutComponent = /*#__PURE__*/(() => {\n  class LogoutComponent {\n    constructor(authorizeService, activatedRoute, router) {\n      this.authorizeService = authorizeService;\n      this.activatedRoute = activatedRoute;\n      this.router = router;\n      this.message = new BehaviorSubject(null);\n    }\n\n    ngOnInit() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const action = _this.activatedRoute.snapshot.url[1];\n\n        switch (action.path) {\n          case LogoutActions.Logout:\n            if (!!window.history.state.local) {\n              yield _this.logout(_this.getReturnUrl());\n            } else {\n              // This prevents regular links to <app>/authentication/logout from triggering a logout\n              _this.message.next('The logout was not initiated from within the page.');\n            }\n\n            break;\n\n          case LogoutActions.LogoutCallback:\n            yield _this.processLogoutCallback();\n            break;\n\n          case LogoutActions.LoggedOut:\n            _this.message.next('You successfully logged out!');\n\n            break;\n\n          default:\n            throw new Error(`Invalid action '${action}'`);\n        }\n      })();\n    }\n\n    logout(returnUrl) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const state = {\n          returnUrl\n        };\n        const isauthenticated = yield _this2.authorizeService.isAuthenticated().pipe(take(1)).toPromise();\n\n        if (isauthenticated) {\n          const result = yield _this2.authorizeService.signOut(state);\n\n          switch (result.status) {\n            case AuthenticationResultStatus.Redirect:\n              break;\n\n            case AuthenticationResultStatus.Success:\n              yield _this2.navigateToReturnUrl(returnUrl);\n              break;\n\n            case AuthenticationResultStatus.Fail:\n              _this2.message.next(result.message);\n\n              break;\n\n            default:\n              throw new Error('Invalid authentication result status.');\n          }\n        } else {\n          _this2.message.next('You successfully logged out!');\n        }\n      })();\n    }\n\n    processLogoutCallback() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const url = window.location.href;\n        const result = yield _this3.authorizeService.completeSignOut(url);\n\n        switch (result.status) {\n          case AuthenticationResultStatus.Redirect:\n            // There should not be any redirects as the only time completeAuthentication finishes\n            // is when we are doing a redirect sign in flow.\n            throw new Error('Should not redirect.');\n\n          case AuthenticationResultStatus.Success:\n            yield _this3.navigateToReturnUrl(_this3.getReturnUrl(result.state));\n            break;\n\n          case AuthenticationResultStatus.Fail:\n            _this3.message.next(result.message);\n\n            break;\n\n          default:\n            throw new Error('Invalid authentication result status.');\n        }\n      })();\n    }\n\n    navigateToReturnUrl(returnUrl) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this4.router.navigateByUrl(returnUrl, {\n          replaceUrl: true\n        });\n      })();\n    }\n\n    getReturnUrl(state) {\n      const fromQuery = this.activatedRoute.snapshot.queryParams.returnUrl; // If the url is coming from the query string, check that is either\n      // a relative url or an absolute url\n\n      if (fromQuery && !(fromQuery.startsWith(`${window.location.origin}/`) || /\\/[^\\/].*/.test(fromQuery))) {\n        // This is an extra check to prevent open redirects.\n        throw new Error('Invalid return url. The return url needs to have the same origin as the current page.');\n      }\n\n      return state && state.returnUrl || fromQuery || ApplicationPaths.LoggedOut;\n    }\n\n  }\n\n  LogoutComponent.ɵfac = function LogoutComponent_Factory(t) {\n    return new (t || LogoutComponent)(i0.ɵɵdirectiveInject(i1.AuthorizeService), i0.ɵɵdirectiveInject(i2.ActivatedRoute), i0.ɵɵdirectiveInject(i2.Router));\n  };\n\n  LogoutComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: LogoutComponent,\n    selectors: [[\"app-logout\"]],\n    decls: 3,\n    vars: 3,\n    template: function LogoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"p\");\n        i0.ɵɵtext(1);\n        i0.ɵɵpipe(2, \"async\");\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, ctx.message));\n      }\n    },\n    dependencies: [i3.AsyncPipe]\n  });\n  return LogoutComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}